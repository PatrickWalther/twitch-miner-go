{{define "title"}}{{.Streamer.Name}} - Twitch Points Miner{{end}}

{{define "content"}}
<a href="/" class="inline-flex items-center gap-2 text-neutral-400 hover:text-purple-500 mb-4 transition-colors">
    ← Back to Dashboard
</a>

<h1 class="text-3xl font-bold text-purple-500 mb-6">{{.Streamer.Name}}</h1>

<div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
    <article class="stat-card">
        <div class="text-3xl font-bold text-purple-500" id="current-points">{{.Streamer.Points}}</div>
        <div class="text-neutral-400 mt-2">Current Points</div>
    </article>
    <article class="stat-card">
        <div class="text-3xl font-bold text-purple-500" id="points-gained">{{.PointsGained}}</div>
        <div class="text-neutral-400 mt-2">Points Gained ({{.DaysAgo}}d)</div>
    </article>
    <article class="stat-card">
        <div class="text-3xl font-bold text-purple-500" id="data-points">{{.DataPoints}}</div>
        <div class="text-neutral-400 mt-2">Data Points</div>
    </article>
</div>

<div class="chart-container">
    <h3 class="text-lg font-semibold mb-4">Points Over Time</h3>
    <div id="points-chart"></div>
</div>

<div class="chart-container">
    <h3 class="text-lg font-semibold mb-4">Date Range</h3>
    <form id="date-filter" class="flex flex-wrap gap-4 items-end">
        <label class="flex flex-col gap-1">
            <span class="text-sm text-neutral-400">Start Date</span>
            <input type="date" id="start-date" name="startDate" class="input-field">
        </label>
        <label class="flex flex-col gap-1">
            <span class="text-sm text-neutral-400">End Date</span>
            <input type="date" id="end-date" name="endDate" class="input-field">
        </label>
        <button type="submit" class="btn-primary">Apply</button>
    </form>
</div>

<div class="chart-container">
    <h3 class="text-lg font-semibold mb-4">Chat Log</h3>
    <div class="flex items-center gap-2 mb-4">
        <input type="text" id="chat-search" placeholder="Search messages..." autocomplete="off" class="input-field flex-1">
        <button id="chat-search-clear" class="hidden px-3 py-2 bg-neutral-700 rounded-md text-neutral-100 hover:bg-neutral-400/20">✕</button>
        <span id="chat-search-info" class="text-xs text-neutral-400"></span>
    </div>
    <div id="chat-log" class="h-96 overflow-y-auto relative">
        <div class="chat-messages flex flex-col gap-1" id="chat-messages"></div>
        <div class="chat-loading hidden text-center p-4 text-neutral-400" id="chat-loading">Loading...</div>
    </div>
</div>
{{end}}

{{define "scripts"}}
<script>
    const streamerName = "{{.Streamer.Name}}";
    let chart = null;
    
    async function loadChart(startDate, endDate) {
        let url = '/json/' + streamerName;
        const params = new URLSearchParams();
        if (startDate) params.set('startDate', startDate);
        if (endDate) params.set('endDate', endDate);
        if (params.toString()) url += '?' + params.toString();
        
        const response = await fetch(url);
        const data = await response.json();
        
        const series = data.series || [];
        const annotations = data.annotations || [];
        
        const chartData = series.map(p => ({
            x: p.x,
            y: p.y
        }));
        
        const xAxisAnnotations = annotations.map(a => ({
            x: a.x,
            borderColor: a.borderColor,
            label: {
                style: {
                    color: '#000',
                    background: a.borderColor
                },
                text: a.label.text
            }
        }));
        
        const options = {
            series: [{
                name: 'Points',
                data: chartData
            }],
            chart: {
                type: 'area',
                height: 400,
                background: 'transparent',
                foreColor: '#adadb8',
                toolbar: {
                    show: true,
                    tools: {
                        download: false,
                        selection: true,
                        zoom: true,
                        zoomin: true,
                        zoomout: true,
                        pan: true,
                        reset: true
                    }
                },
                animations: {
                    enabled: true,
                    easing: 'easeinout',
                    speed: 300
                }
            },
            colors: ['#9146ff'],
            fill: {
                type: 'gradient',
                gradient: {
                    shadeIntensity: 1,
                    opacityFrom: 0.7,
                    opacityTo: 0.2,
                    stops: [0, 100]
                }
            },
            stroke: {
                curve: 'smooth',
                width: 2
            },
            dataLabels: {
                enabled: false
            },
            xaxis: {
                type: 'datetime',
                labels: {
                    datetimeUTC: false
                }
            },
            yaxis: {
                labels: {
                    formatter: function(val) {
                        return new Intl.NumberFormat().format(val);
                    }
                }
            },
            tooltip: {
                theme: 'dark',
                x: {
                    format: 'MMM dd, yyyy HH:mm'
                },
                y: {
                    formatter: function(val, opts) {
                        const point = series[opts.dataPointIndex];
                        let label = new Intl.NumberFormat().format(val) + ' points';
                        if (point && point.z) {
                            label += ' (' + point.z + ')';
                        }
                        return label;
                    }
                }
            },
            annotations: {
                xaxis: xAxisAnnotations
            },
            grid: {
                borderColor: '#303033',
                strokeDashArray: 4
            }
        };
        
        if (chart) {
            chart.updateOptions(options);
        } else {
            chart = new ApexCharts(document.getElementById('points-chart'), options);
            chart.render();
        }
    }
    
    function formatLocalDate(date) {
        return date.toLocaleDateString('en-CA');
    }
    
    function initDefaultDates() {
        const now = new Date();
        const startDate = new Date(now);
        startDate.setDate(now.getDate() - {{.DaysAgo}});
        
        document.getElementById('start-date').value = formatLocalDate(startDate);
        document.getElementById('end-date').value = formatLocalDate(now);
    }
    
    initDefaultDates();
    
    document.getElementById('date-filter').addEventListener('submit', function(e) {
        e.preventDefault();
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        loadChart(startDate, endDate);
    });
    
    loadChart(
        document.getElementById('start-date').value,
        document.getElementById('end-date').value
    );
    
    setInterval(function() {
        loadChart(
            document.getElementById('start-date').value,
            document.getElementById('end-date').value
        );
    }, {{.RefreshMinutes}} * 60 * 1000);
    
    const chatState = {
        messages: [],
        totalCount: 0,
        offset: 0,
        limit: 50,
        buffer: 20,
        loading: false,
        searchQuery: '',
        searchTimeout: null
    };
    
    const chatContainer = document.getElementById('chat-log');
    const chatMessages = document.getElementById('chat-messages');
    const chatLoading = document.getElementById('chat-loading');
    const chatSearch = document.getElementById('chat-search');
    const chatSearchClear = document.getElementById('chat-search-clear');
    const chatSearchInfo = document.getElementById('chat-search-info');
    
    function parseEmotes(message, emoteStr) {
        if (!emoteStr) return escapeHtml(message);
        
        const emotes = [];
        const emoteParts = emoteStr.split('/');
        
        for (const part of emoteParts) {
            const [emoteId, positions] = part.split(':');
            if (!positions) continue;
            
            const ranges = positions.split(',');
            for (const range of ranges) {
                const [start, end] = range.split('-').map(Number);
                emotes.push({
                    id: emoteId,
                    start: start,
                    end: end + 1,
                    text: message.substring(start, end + 1)
                });
            }
        }
        
        emotes.sort((a, b) => b.start - a.start);
        
        let result = message;
        for (const emote of emotes) {
            const emoteUrl = `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/1.0`;
            const img = `<img class="h-6 align-middle mx-0.5 inline" src="${emoteUrl}" alt="${escapeHtml(emote.text)}" title="${escapeHtml(emote.text)}">`;
            result = result.substring(0, emote.start) + img + result.substring(emote.end);
        }
        
        return result.replace(/([^<]*)(<[^>]+>)?/g, function(match, text, tag) {
            return (text ? escapeHtml(text) : '') + (tag || '');
        }).replace(/&lt;img/g, '<img').replace(/&gt;/g, '>').replace(/&quot;/g, '"');
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function formatChatTimestamp(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString([], { 
            month: 'short', 
            day: 'numeric',
            hour: '2-digit', 
            minute: '2-digit' 
        });
    }
    
    function highlightSearch(text, query) {
        if (!query) return text;
        const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        return text.replace(regex, '<mark class="bg-purple-600 text-white px-0.5 rounded-sm">$1</mark>');
    }
    
    function renderChatMessage(msg, searchQuery = '') {
        const color = msg.color || '#9146ff';
        const displayName = msg.display_name || msg.username;
        let messageHtml = parseEmotes(msg.message, msg.emotes);
        
        if (searchQuery) {
            messageHtml = highlightSearch(messageHtml, searchQuery);
        }
        
        return `
            <div class="p-2 bg-neutral-900 rounded text-sm leading-relaxed min-h-[32px]" data-id="${msg.id}">
                <span class="text-neutral-400/50 text-xs mr-2">${formatChatTimestamp(msg.timestamp)}</span>
                <span class="font-bold mr-1" style="color: ${escapeHtml(color)}">${escapeHtml(displayName)}:</span>
                <span class="text-neutral-100">${messageHtml}</span>
            </div>
        `;
    }
    
    async function fetchChatMessages(offset = 0, append = false) {
        if (chatState.loading) return;
        chatState.loading = true;
        chatLoading.classList.remove('hidden');
        
        try {
            let url = `/api/chat/${streamerName}?limit=${chatState.limit}&offset=${offset}`;
            if (chatState.searchQuery) {
                url += `&q=${encodeURIComponent(chatState.searchQuery)}`;
            }
            
            const response = await fetch(url);
            const data = await response.json();
            
            chatState.totalCount = data.total_count;
            
            if (append) {
                chatState.messages = [...chatState.messages, ...data.messages];
            } else {
                chatState.messages = data.messages || [];
                chatState.offset = 0;
            }
            
            chatState.offset = offset + (data.messages?.length || 0);
            
            updateChatSearchInfo();
            renderVisibleMessages();
            
        } catch (err) {
            console.error('Failed to load chat messages:', err);
        } finally {
            chatState.loading = false;
            chatLoading.classList.add('hidden');
        }
    }
    
    function updateChatSearchInfo() {
        if (chatState.searchQuery) {
            chatSearchInfo.textContent = `${chatState.totalCount} results`;
        } else {
            chatSearchInfo.textContent = chatState.totalCount > 0 ? `${chatState.totalCount} messages` : '';
        }
    }
    
    function renderVisibleMessages() {
        if (chatState.messages.length === 0) {
            const msg = chatState.searchQuery 
                ? 'No messages found for your search' 
                : 'No chat messages recorded';
            chatMessages.innerHTML = `<div class="text-neutral-400 text-center py-8">${msg}</div>`;
            return;
        }
        
        const html = chatState.messages.map(msg => 
            renderChatMessage(msg, chatState.searchQuery)
        ).join('');
        chatMessages.innerHTML = html;
    }
    
    function handleScroll() {
        const { scrollTop, scrollHeight, clientHeight } = chatContainer;
        const scrollBottom = scrollHeight - scrollTop - clientHeight;
        
        if (scrollBottom < 100 && !chatState.loading && chatState.offset < chatState.totalCount) {
            fetchChatMessages(chatState.offset, true);
        }
    }
    
    function handleSearch() {
        const query = chatSearch.value.trim();
        chatState.searchQuery = query;
        chatSearchClear.classList.toggle('hidden', !query);
        fetchChatMessages(0, false);
    }
    
    function clearSearch() {
        chatSearch.value = '';
        chatState.searchQuery = '';
        chatSearchClear.classList.add('hidden');
        fetchChatMessages(0, false);
    }
    
    chatContainer.addEventListener('scroll', handleScroll);
    
    chatSearch.addEventListener('input', function() {
        clearTimeout(chatState.searchTimeout);
        chatState.searchTimeout = setTimeout(handleSearch, 300);
    });
    
    chatSearch.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            clearSearch();
        }
    });
    
    chatSearchClear.addEventListener('click', clearSearch);
    
    fetchChatMessages(0, false);
    
    setInterval(function() {
        if (!chatState.searchQuery) {
            fetchChatMessages(0, false);
        }
    }, {{.RefreshMinutes}} * 60 * 1000);
</script>
{{end}}
